<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mesh - Connect Without Boundaries</title>
    
    <!-- React CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- QR Code Dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 0;
            margin: 0;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 0;
            box-shadow: none;
            width: 100%;
            max-width: none;
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .header {
            padding: 15px 20px;
            background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            text-align: center;
            position: relative;
            min-height: 60px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .header h1 {
            font-size: 1.8em;
            margin-bottom: 5px;
        }

        .status {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .main-content {
            display: flex;
            flex: 1;
            min-height: 0;
            overflow: hidden;
        }

        .sidebar {
            width: 350px;
            background: rgba(0, 0, 0, 0.05);
            padding: 25px;
            border-right: 1px solid rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease;
            position: relative;
            z-index: 10;
            overflow-y: auto;
            flex-shrink: 0;
        }
        
        .sidebar.full-width {
            width: 100%;
            border-right: none;
            overflow-y: auto;
            flex-shrink: 0;
        }

        /* Drawer styles when chat is active */
        .sidebar.drawer {
            position: fixed;
            top: 0;
            left: 0;
            height: 100vh;
            width: 90vw;
            max-width: 400px;
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(10px);
            box-shadow: 2px 0 20px rgba(0, 0, 0, 0.15);
            border-right: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 0;
            transform: translateX(-100%);
            overflow-y: auto;
            z-index: 1000;
            padding: 60px 25px 25px 25px;
        }

        .sidebar.drawer.open {
            transform: translateX(0);
            background: rgba(255, 255, 255, 1);
        }

        /* Drawer overlay */
        .drawer-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(2px);
            z-index: 999;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .drawer-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        /* Drawer toggle button */
        .drawer-toggle {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1001;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            min-width: 40px;
            min-height: 40px;
            font-size: 1em;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transition: all 0.3s ease;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 0;
            overflow: hidden;
        }

        .drawer-toggle:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
        }

        .drawer-toggle.visible {
            display: flex !important;
        }

        .main-connection-section {
            background: rgba(255, 255, 255, 0.7);
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 30px;
            border: 2px solid rgba(102, 126, 234, 0.2);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }

        .main-connection-section h3 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.2em;
            text-align: center;
            font-weight: 600;
        }

        button {
            border: none;
            border-radius: 12px;
            padding: 16px 20px;
            font-size: 1.1em;
            outline: none;
            transition: all 0.3s ease;
            margin: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            cursor: pointer;
            font-weight: 600;
            min-width: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .main-connection-section button {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            padding: 12px 20px;
            border-radius: 10px;
            font-size: 0.95em;
            min-width: auto;
            height: auto;
            box-shadow: 0 3px 10px rgba(79, 172, 254, 0.3);
        }

        .main-connection-section button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(79, 172, 254, 0.4);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .role-buttons {
            display: flex;
            gap: 0.8em;
            margin-bottom: 15px;
        }

        .role-buttons button {
            flex: 1;
            padding: 15px;
            font-size: 0.9em;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            border: 2px solid rgba(79, 172, 254, 0.3);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .role-buttons button:hover {
            background: rgba(79, 172, 254, 0.1);
            border-color: rgba(79, 172, 254, 0.5);
        }

        .back-button {
            background: #f5f5f5 !important;
            color: #666 !important;
            font-size: 0.9em !important;
        }

        textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            font-family: monospace;
            font-size: 0.9em;
            resize: none;
            margin: 10px 0;
            box-sizing: border-box;
        }

        textarea:focus {
            border-color: #667eea;
            outline: none;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        input {
            width: 100%;
            padding: 12px;
            border: 2px solid rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            font-size: 1em;
            margin: 8px 0;
            box-sizing: border-box;
        }

        input:focus {
            border-color: #667eea;
            outline: none;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .collapsible-sections-container {
            padding: 25px;
            padding-top: 0;
        }

        .collapsible-section {
            margin-bottom: 25px;
        }

        .section-header {
            background: rgba(255, 255, 255, 0.4);
            padding: 12px 15px;
            border-radius: 12px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s ease;
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        .section-header:hover {
            background: rgba(255, 255, 255, 0.6);
        }

        .section-header h3 {
            color: #333;
            font-size: 0.95em;
            margin: 0;
            font-weight: 600;
        }

        .section-toggle {
            font-size: 0.9em;
            transition: transform 0.3s ease;
            color: #667eea;
        }

        .section-toggle.expanded {
            transform: rotate(180deg);
        }

        .section-content {
            padding: 15px;
            background: rgba(255, 255, 255, 0.6);
            margin-top: 5px;
            border-radius: 12px;
        }

        .peer-list {
            margin-top: 15px;
        }

        .peer-item {
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 8px;
            font-size: 0.9em;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .peer-item:hover {
            background: rgba(255, 255, 255, 0.95);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .peer-item .peer-name {
            flex: 1;
            font-weight: 500;
        }

        .peer-item .dm-button {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border: none;
            border-radius: 15px;
            padding: 4px 8px;
            font-size: 0.7em;
            cursor: pointer;
            margin-left: 8px;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .peer-item:hover .dm-button {
            opacity: 1;
        }

        .peer-status {
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: 600;
        }

        .peer-status.connected {
            background: #4ade80;
            color: white;
        }

        .peer-status.connecting {
            background: #fbbf24;
            color: white;
        }

        .peer-status.failed {
            background: #ef4444;
            color: white;
        }

        .chat-area {
            flex: 1;
            display: none;
            flex-direction: column;
            position: relative;
        }

        .chat-area.connected {
            display: flex;
        }

        .messages {
            flex: 1;
            padding: 20px;
            background: rgba(255, 255, 255, 0.3);
            overflow-y: auto;
            scroll-behavior: smooth;
            min-height: 0;
        }

        .message {
            margin-bottom: 15px;
            padding: 12px 16px;
            border-radius: 18px;
            max-width: 70%;
            word-wrap: break-word;
        }

        .message.own {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            margin-left: auto;
        }

        .message.peer {
            background: white;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .message-header {
            font-size: 0.8em;
            opacity: 0.7;
            margin-bottom: 5px;
        }

        .message-content {
            font-size: 1em;
            line-height: 1.4;
        }

        .input-area {
            padding: 25px;
            background: rgba(255, 255, 255, 0.9);
            border-top: 1px solid rgba(0, 0, 0, 0.1);
            min-height: 120px;
        }

        .input-group {
            display: flex;
            gap: 15px;
            align-items: stretch;
            height: 60px;
        }

        .input-group input {
            flex: 1;
            height: 60px;
            margin: 0;
        }

        .input-group button {
            height: 60px;
        }

        .call-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .call-controls button {
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 0.9em;
        }

        .video-streams {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .video-container {
            position: relative;
        }

        .video-container video {
            width: 300px;
            height: 200px;
            background: #000;
            border-radius: 10px;
        }

        .identity-section {
            background: rgba(255, 255, 255, 0.6);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 25px;
        }

        .key-display {
            font-family: monospace;
            font-size: 0.8em;
            background: rgba(0, 0, 0, 0.1);
            padding: 8px;
            border-radius: 6px;
            word-break: break-all;
            margin-top: 8px;
        }

        .stats {
            font-size: 0.85em;
            color: #666;
            margin-top: 10px;
        }

        .privacy-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 0.8em;
            margin-top: 0.8em;
        }

        .privacy-card {
            background: rgba(255, 255, 255, 0.7);
            padding: 18px;
            border-radius: 12px;
            border-left: 4px solid #667eea;
            transition: all 0.2s ease;
        }

        .privacy-card:hover {
            background: rgba(255, 255, 255, 0.9);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .privacy-card h4 {
            color: #333;
            margin: 0 0 10px 0;
            font-size: 1em;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .privacy-card p {
            color: #666;
            margin: 0;
            font-size: 0.9em;
            line-height: 1.5;
        }

        .privacy-comparison {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
        }

        .comparison-table {
            display: grid;
            grid-template-columns: 1.2fr 0.8fr 0.8fr;
            gap: 0.8em;
            text-align: center;
            font-size: 0.85em;
        }

        .comparison-header {
            font-weight: 600;
            color: #333;
            padding: 10px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 8px;
            font-size: 0.9em;
        }

        .comparison-item {
            padding: 6px;
            font-size: 0.75em;
            border-radius: 6px;
        }

        .comparison-mesh {
            background: rgba(76, 175, 80, 0.2);
            color: #2e7d32;
            font-weight: 600;
        }

        .comparison-traditional {
            background: rgba(244, 67, 54, 0.2);
            color: #c62828;
        }

        .chat-tabs-sidebar {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .chat-tab {
            padding: 12px 15px;
            border-radius: 10px;
            border: none;
            background: rgba(255, 255, 255, 0.8);
            color: #333;
            font-size: 0.9em;
            text-align: left;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            transition: all 0.2s ease;
            width: 100%;
        }

        .chat-tab:hover {
            background: rgba(255, 255, 255, 0.9) !important;
            transform: translateY(-1px);
        }

        .chat-tab.active {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%) !important;
            color: white !important;
            box-shadow: 0 2px 8px rgba(79, 172, 254, 0.3);
        }

        .unread-indicator {
            background: #dc3545;
            color: white;
            border-radius: 50%;
            min-width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8em;
            font-weight: bold;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }

        .modal.show {
            display: block;
        }

        .modal-content {
            background: white;
            margin: 10% auto;
            padding: 25px;
            border-radius: 15px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #f0f0f0;
        }

        .modal-title {
            color: #333;
            font-size: 1.3em;
            font-weight: 600;
            margin: 0;
        }

        .modal-close {
            background: none !important;
            border: none !important;
            font-size: 24px !important;
            cursor: pointer;
            color: #666;
            padding: 5px !important;
            border-radius: 50% !important;
            width: 35px !important;
            height: 35px !important;
            min-width: 35px !important;
            display: flex !important;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            margin: 0 !important;
        }

        .modal-close:hover {
            background: #f0f0f0 !important;
            color: #333;
        }

        .modal-textarea {
            width: 100%;
            min-height: 120px;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-family: monospace;
            font-size: 0.9em;
            resize: none;
            margin: 8px 0;
            box-sizing: border-box;
        }

        .modal-buttons {
            display: flex;
            gap: 0.8em;
            justify-content: flex-end;
            margin-top: 15px;
        }

        .modal-button {
            padding: 10px 20px !important;
            border: none !important;
            border-radius: 8px !important;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
            min-width: 100px !important;
            font-size: 0.9em !important;
        }

        .modal-button.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
            color: white !important;
        }

        .modal-button.secondary {
            background: #f5f5f5 !important;
            color: #666 !important;
            border: 1px solid #ddd !important;
        }

        .camera-container {
            position: relative;
            display: inline-block;
            border-radius: 12px;
            overflow: hidden;
            background: #000;
            margin: 10px 0;
        }

        .camera-container video {
            width: 100%;
            max-width: 300px;
            height: auto;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            .sidebar.full-width {
                width: 100%;
            }
            
            .collapsible-sections-container {
                padding: 15px;
                padding-top: 0;
            }

            .sidebar.drawer {
                width: 90vw;
                max-width: 350px;
                padding: 60px 20px 20px 20px;
                height: 100vh;
            }

            .drawer-toggle {
                top: 15px;
                left: 15px;
                width: 45px;
                height: 45px;
                font-size: 1.1em;
            }

            .chat-area.connected {
                height: 100vh;
            }

            .messages {
                padding: 15px;
                min-height: calc(100vh - 200px);
            }

            .input-area {
                padding: 15px;
                position: sticky;
                bottom: 0;
                background: rgba(255, 255, 255, 0.95);
                backdrop-filter: blur(10px);
            }
        }

        /* Desktop specific */
        @media (min-width: 769px) {
            .main-content.chat-active .sidebar.drawer {
                position: fixed;
                top: 0;
                left: 0;
                height: 100vh;
                width: 400px;
                transform: translateX(-100%);
                z-index: 1000;
                background: rgba(255, 255, 255, 0.98);
                backdrop-filter: blur(10px);
                padding: 80px 25px 25px 25px;
            }
            
            .main-content.chat-active .sidebar.drawer.open {
                transform: translateX(0);
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // WebRTC Configuration
        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' }
            ]
        };

        // Crypto utilities
        const generateKeyPair = async () => {
            const keyPair = await window.crypto.subtle.generateKey(
                {
                    name: "ECDSA",
                    namedCurve: "P-256"
                },
                true,
                ["sign", "verify"]
            );
            return keyPair;
        };

        const exportPublicKey = async (publicKey) => {
            const exported = await window.crypto.subtle.exportKey("raw", publicKey);
            const exportedAsString = String.fromCharCode.apply(null, new Uint8Array(exported));
            return btoa(exportedAsString);
        };

        const signMessage = async (message, privateKey) => {
            const encoder = new TextEncoder();
            const data = encoder.encode(message);
            const signature = await window.crypto.subtle.sign(
                { name: 'ECDSA', hash: 'SHA-256' },
                privateKey,
                data
            );
            return Array.from(new Uint8Array(signature))
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
        };

        const verifyMessage = async (messageData) => {
            try {
                const { signature, publicKey, ...messageContent } = messageData;
                const messageString = JSON.stringify(messageContent);
                
                const publicKeyBuffer = new Uint8Array(
                    atob(publicKey).split('').map(char => char.charCodeAt(0))
                );
                
                const cryptoPublicKey = await window.crypto.subtle.importKey(
                    'raw',
                    publicKeyBuffer,
                    { name: 'ECDSA', namedCurve: 'P-256' },
                    false,
                    ['verify']
                );

                const signatureBuffer = new Uint8Array(
                    signature.match(/.{2}/g).map(byte => parseInt(byte, 16))
                );

                const encoder = new TextEncoder();
                const data = encoder.encode(messageString);

                return await window.crypto.subtle.verify(
                    { name: 'ECDSA', hash: 'SHA-256' },
                    cryptoPublicKey,
                    signatureBuffer,
                    data
                );
            } catch (error) {
                console.error('Signature verification failed:', error);
                return false;
            }
        };

        // Utility functions
        const generatePeerId = () => 'peer_' + Math.random().toString(36).substr(2, 9);
        const generateMessageId = () => 'msg_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
        const generateRoomCode = () => {
            const adjectives = ['BLUE', 'RED', 'GREEN', 'FAST', 'COOL', 'BRIGHT', 'SHARP', 'SWIFT'];
            const nouns = ['WOLF', 'TREE', 'ROCK', 'STAR', 'WAVE', 'FIRE', 'MOON', 'BIRD'];
            const numbers = Math.floor(Math.random() * 100).toString().padStart(2, '0');
            
            const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
            const noun = nouns[Math.floor(Math.random() * nouns.length)];
            
            return `${adj}-${noun}-${numbers}`;
        };

        const copyToClipboard = async (text) => {
            try {
                await navigator.clipboard.writeText(text);
                return true;
            } catch (error) {
                console.error('Failed to copy:', error);
                return false;
            }
        };

        // Modal Component
        const Modal = ({ show, title, content, onClose, onCopy, isEditable = false, customContent }) => {
            const textareaRef = useRef(null);

            useEffect(() => {
                if (show && textareaRef.current && !isEditable) {
                    setTimeout(() => {
                        textareaRef.current.focus();
                        textareaRef.current.select();
                    }, 100);
                }
            }, [show, isEditable]);

            const handleCopy = async () => {
                const success = await copyToClipboard(content);
                if (success && onCopy) {
                    onCopy();
                }
            };

            if (!show) return null;

            return (
                <div className="modal show">
                    <div className="modal-content">
                        <div className="modal-header">
                            <h3 className="modal-title">{title}</h3>
                            <button className="modal-close" onClick={onClose}>&times;</button>
                        </div>
                        <div className="modal-body">
                            {customContent ? (
                                <div dangerouslySetInnerHTML={{ __html: customContent }} />
                            ) : (
                                <textarea
                                    ref={textareaRef}
                                    className="modal-textarea"
                                    value={content}
                                    readOnly={!isEditable}
                                    onChange={(e) => isEditable && onContentChange && onContentChange(e.target.value)}
                                />
                            )}
                        </div>
                        {!customContent && (
                            <div className="modal-buttons">
                                <button className="modal-button secondary" onClick={onClose}>Close</button>
                                <button className="modal-button primary" onClick={handleCopy}>üìã Copy</button>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // CollapsibleSection Component
        const CollapsibleSection = ({ title, children, expanded, onToggle }) => {
            return (
                <div className="collapsible-section">
                    <div className="section-header" onClick={onToggle}>
                        <h3>{title}</h3>
                        <span className={`section-toggle ${expanded ? 'expanded' : ''}`}>‚ñº</span>
                    </div>
                    {expanded && (
                        <div className="section-content">
                            {children}
                        </div>
                    )}
                </div>
            );
        };

        // Main App Component
        const App = () => {
            const [connectionState, setConnectionState] = useState('disconnected');
            const [peers, setPeers] = useState(new Map());
            const [messages, setMessages] = useState([]);
            const [username, setUsername] = useState('Anonymous');
            const [keyPair, setKeyPair] = useState(null);
            const [publicKey, setPublicKey] = useState('');
            const [currentView, setCurrentView] = useState('connect');
            const [offerData, setOfferData] = useState('');
            const [answerData, setAnswerData] = useState('');
            const [remoteOfferData, setRemoteOfferData] = useState('');
            const [isInCall, setIsInCall] = useState(false);
            const [localStream, setLocalStream] = useState(null);
            const [remoteStream, setRemoteStream] = useState(null);
            const [sectionsExpanded, setSectionsExpanded] = useState({
                peers: false,
                identity: false,
                stats: false,
                privacy: false
            });
            const [activeChats, setActiveChats] = useState(new Map([
                ['group', {
                    type: 'group',
                    messages: [],
                    unreadCount: 0,
                    name: 'Group Chat'
                }]
            ]));
            const [currentChatId, setCurrentChatId] = useState('group');
            const [drawerOpen, setDrawerOpen] = useState(false);
            const [showModal, setShowModal] = useState(false);
            const [modalData, setModalData] = useState({ title: '', content: '', customContent: null });
            const [messagesSent, setMessagesSent] = useState(0);
            const [messagesReceived, setMessagesReceived] = useState(0);
            const [messagesRelayed, setMessagesRelayed] = useState(0);
            const [roomCode, setRoomCode] = useState('');
            const [currentRoomCode, setCurrentRoomCode] = useState('');
            const [seenMessages] = useState(new Set());
            const [qrScanning, setQrScanning] = useState(false);

            const localVideoRef = useRef(null);
            const remoteVideoRef = useRef(null);
            const peerConnections = useRef(new Map());
            const messageInputRef = useRef(null);
            const qrVideoRef = useRef(null);
            const pendingOffer = useRef(null);

            // Initialize crypto keys on mount
            useEffect(() => {
                const initKeys = async () => {
                    try {
                        const keys = await generateKeyPair();
                        setKeyPair(keys);
                        const pubKey = await exportPublicKey(keys.publicKey);
                        setPublicKey(pubKey.substring(0, 32) + '...');
                    } catch (error) {
                        console.error('Failed to generate keys:', error);
                    }
                };
                initKeys();
            }, []);

            // Add system message on mount
            useEffect(() => {
                setMessages([{
                    id: Date.now(),
                    sender: 'System',
                    content: 'Welcome to serverless P2P chat! Connect to someone to start messaging.',
                    timestamp: new Date(),
                    isOwn: false
                }]);
            }, []);

            const addMessage = useCallback((sender, content, isOwn = false, chatId = 'group') => {
                const newMessage = {
                    id: Date.now() + Math.random(),
                    sender,
                    content,
                    timestamp: new Date(),
                    isOwn
                };

                if (chatId === currentChatId) {
                    setMessages(prev => [...prev, newMessage]);
                } else {
                    // Add to specific chat and increment unread count
                    setActiveChats(prev => {
                        const newChats = new Map(prev);
                        if (newChats.has(chatId)) {
                            const chat = newChats.get(chatId);
                            chat.messages.push(newMessage);
                            if (!isOwn) chat.unreadCount++;
                        }
                        return newChats;
                    });
                }
            }, [currentChatId]);

            const createPeerConnection = useCallback(async (peerId) => {
                const pc = new RTCPeerConnection(rtcConfig);
                
                pc.onicecandidate = (event) => {
                    if (event.candidate) {
                        console.log('ICE candidate:', event.candidate);
                    }
                };

                pc.ondatachannel = (event) => {
                    const channel = event.channel;
                    channel.onmessage = async (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            await handleIncomingMessage(data);
                        } catch (error) {
                            console.error('Failed to parse message:', error);
                        }
                    };
                };

                pc.ontrack = (event) => {
                    setRemoteStream(event.streams[0]);
                    if (remoteVideoRef.current) {
                        remoteVideoRef.current.srcObject = event.streams[0];
                    }
                };

                pc.onconnectionstatechange = () => {
                    console.log('Connection state:', pc.connectionState);
                    if (pc.connectionState === 'connected') {
                        setConnectionState('connected');
                        addMessage('System', 'Connected to peer!');
                    } else if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed') {
                        setConnectionState('disconnected');
                        addMessage('System', 'Disconnected from peer');
                    }
                };

                peerConnections.current.set(peerId, pc);
                return pc;
            }, [addMessage]);

            const handleIncomingMessage = async (messageData) => {
                // Handle call signals
                if (messageData.type === 'call-signal') {
                    // Handle call signaling
                    return;
                }
                
                // Check if we've seen this message before
                if (seenMessages.has(messageData.id)) {
                    return;
                }

                // Verify signature
                const isValid = await verifyMessage(messageData);
                if (!isValid) {
                    console.warn('Invalid message signature');
                    return;
                }

                seenMessages.add(messageData.id);
                
                // Add to chat if it's not from us
                if (messageData.publicKey !== await exportPublicKey(keyPair.publicKey)) {
                    let chatId = 'group';
                    if (messageData.targetPeerId) {
                        // This is a DM - check if it's for us
                        const myPublicKey = await exportPublicKey(keyPair.publicKey);
                        if (messageData.targetPeerId === myPublicKey) {
                            // Find or create DM chat
                            chatId = `dm_${messageData.publicKey}`;
                            if (!activeChats.has(chatId)) {
                                setActiveChats(prev => {
                                    const newChats = new Map(prev);
                                    newChats.set(chatId, {
                                        type: 'dm',
                                        publicKey: messageData.publicKey,
                                        messages: [],
                                        unreadCount: 0,
                                        name: messageData.username
                                    });
                                    return newChats;
                                });
                            }
                        } else {
                            // DM for someone else - just relay
                            relayMessage(messageData);
                            return;
                        }
                    }
                    
                    addMessage(messageData.username, messageData.content, false, chatId);
                    setMessagesReceived(prev => prev + 1);
                }

                // Relay to other peers
                relayMessage(messageData);
            };

            const relayMessage = (messageData) => {
                let relayCount = 0;
                peerConnections.current.forEach(pc => {
                    // In a real implementation, we'd send through data channels
                    relayCount++;
                });
                if (relayCount > 0) {
                    setMessagesRelayed(prev => prev + 1);
                }
            };

            const createOffer = async () => {
                try {
                    const peerId = 'host-' + Date.now();
                    const pc = await createPeerConnection(peerId);
                    
                    // Create data channel
                    const dataChannel = pc.createDataChannel('messages');
                    
                    const offer = await pc.createOffer();
                    await pc.setLocalDescription(offer);
                    
                    const offerString = JSON.stringify({
                        type: 'offer',
                        sdp: offer.sdp,
                        peerId: peerId,
                        username: username,
                        publicKey: publicKey
                    });
                    
                    setOfferData(offerString);
                    setCurrentView('host');
                    setConnectionState('connecting');

                    // Show modal with offer
                    setModalData({
                        title: 'Share This Offer',
                        content: offerString,
                        customContent: null
                    });
                    setShowModal(true);
                } catch (error) {
                    console.error('Failed to create offer:', error);
                    addMessage('System', 'Failed to create offer: ' + error.message);
                }
            };

            const handleOffer = async () => {
                try {
                    const offerObj = JSON.parse(remoteOfferData);
                    const peerId = offerObj.peerId || 'remote-' + Date.now();
                    const pc = await createPeerConnection(peerId);
                    
                    await pc.setRemoteDescription(new RTCSessionDescription({
                        type: 'offer',
                        sdp: offerObj.sdp
                    }));
                    
                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);
                    
                    const answerString = JSON.stringify({
                        type: 'answer',
                        sdp: answer.sdp,
                        peerId: 'joiner-' + Date.now(),
                        username: username,
                        publicKey: publicKey
                    });
                    
                    setAnswerData(answerString);
                    setCurrentView('join-step2');
                    setConnectionState('connecting');
                } catch (error) {
                    console.error('Failed to handle offer:', error);
                    addMessage('System', 'Failed to process offer: ' + error.message);
                }
            };

            const handleAnswer = async () => {
                try {
                    const answerObj = JSON.parse(answerData);
                    const pc = peerConnections.current.values().next().value;
                    
                    if (pc) {
                        await pc.setRemoteDescription(new RTCSessionDescription({
                            type: 'answer',
                            sdp: answerObj.sdp
                        }));
                        addMessage('System', 'Answer processed, establishing connection...');
                    }
                } catch (error) {
                    console.error('Failed to handle answer:', error);
                    addMessage('System', 'Failed to process answer: ' + error.message);
                }
            };

            const sendMessage = () => {
                const input = messageInputRef.current;
                if (!input || !input.value.trim()) return;
                
                const message = input.value.trim();
                
                // Add message to local display
                addMessage(username, message, true);
                setMessagesSent(prev => prev + 1);
                input.value = '';
            };

            const createRoom = () => {
                const newRoomCode = generateRoomCode();
                setCurrentRoomCode(newRoomCode);
                
                const modalContent = `
                    <div style="text-align: center; margin-bottom: 20px;">
                        <h4 style="color: #333; margin-bottom: 15px;">üè† Room Information</h4>
                    </div>
                    <div style="margin-bottom: 20px;">
                        <div style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); color: white; padding: 20px; border-radius: 15px; text-align: center;">
                            <div style="font-size: 0.9em; margin-bottom: 8px;">Room Code:</div>
                            <div style="font-size: 2em; font-weight: bold; letter-spacing: 3px;">${newRoomCode}</div>
                        </div>
                    </div>
                    <div style="margin-bottom: 25px;">
                        <div style="background: rgba(255, 193, 7, 0.1); border: 1px solid rgba(255, 193, 7, 0.3); border-radius: 10px; padding: 15px;">
                            <p style="color: #856404; font-size: 0.9em; margin: 0; line-height: 1.4;"><strong>Important:</strong> Only people already connected to your mesh network can join this room.</p>
                        </div>
                    </div>
                `;

                setModalData({
                    title: 'üè† Room Details',
                    content: '',
                    customContent: modalContent
                });
                setShowModal(true);
            };

            const startQRScanner = async () => {
                try {
                    setQrScanning(true);
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { facingMode: 'environment' } 
                    });
                    
                    if (qrVideoRef.current) {
                        qrVideoRef.current.srcObject = stream;
                    }
                } catch (error) {
                    console.error('Failed to start camera:', error);
                    addMessage('System', 'Camera access failed. Please check permissions.');
                    setQrScanning(false);
                }
            };

            const stopQRScanner = () => {
                if (qrVideoRef.current && qrVideoRef.current.srcObject) {
                    qrVideoRef.current.srcObject.getTracks().forEach(track => track.stop());
                    qrVideoRef.current.srcObject = null;
                }
                setQrScanning(false);
            };

            const startCall = async () => {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: true, 
                        audio: true 
                    });
                    
                    setLocalStream(stream);
                    setIsInCall(true);
                    
                    if (localVideoRef.current) {
                        localVideoRef.current.srcObject = stream;
                    }
                    
                    addMessage('System', 'Call started');
                } catch (error) {
                    console.error('Failed to start call:', error);
                    addMessage('System', 'Failed to start call: ' + error.message);
                }
            };

            const endCall = () => {
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                    setLocalStream(null);
                }
                setRemoteStream(null);
                setIsInCall(false);
                addMessage('System', 'Call ended');
            };

            const toggleSection = (section) => {
                setSectionsExpanded(prev => ({
                    ...prev,
                    [section]: !prev[section]
                }));
            };

            const switchChat = (chatId) => {
                setCurrentChatId(chatId);
                // Load messages for this chat
                const chat = activeChats.get(chatId);
                if (chat) {
                    setMessages(chat.messages || []);
                    // Clear unread count
                    chat.unreadCount = 0;
                    setActiveChats(new Map(activeChats));
                }
            };

            const toggleDrawer = () => {
                setDrawerOpen(prev => !prev);
            };

            const resetFlow = () => {
                setCurrentView('connect');
                setOfferData('');
                setAnswerData('');
                setRemoteOfferData('');
            };

            const generateNewKeys = async () => {
                try {
                    const keys = await generateKeyPair();
                    setKeyPair(keys);
                    const pubKey = await exportPublicKey(keys.publicKey);
                    setPublicKey(pubKey.substring(0, 32) + '...');
                    addMessage('System', 'New identity keys generated');
                } catch (error) {
                    console.error('Failed to generate new keys:', error);
                }
            };

            const exportPrivateKey = async () => {
                if (!keyPair) {
                    addMessage('System', 'No keys generated yet');
                    return;
                }
                
                try {
                    const privateKeyBuffer = await window.crypto.subtle.exportKey('pkcs8', keyPair.privateKey);
                    const privateKeyHex = Array.from(new Uint8Array(privateKeyBuffer))
                        .map(b => b.toString(16).padStart(2, '0'))
                        .join('');
                    
                    setModalData({
                        title: 'Export Private Key',
                        content: privateKeyHex,
                        customContent: null
                    });
                    setShowModal(true);
                } catch (error) {
                    console.error('Failed to export private key:', error);
                    addMessage('System', 'Failed to export private key');
                }
            };

            const copyModalContent = () => {
                addMessage('System', 'Content copied to clipboard');
                setShowModal(false);
            };

            const closeModal = () => {
                setShowModal(false);
            };

            return (
                <div className="container">
                    {/* Drawer toggle button */}
                    {connectionState === 'connected' && (
                        <button 
                            className={`drawer-toggle ${connectionState === 'connected' ? 'visible' : ''}`}
                            onClick={toggleDrawer}
                        >
                            ‚ò∞
                        </button>
                    )}
                    
                    {/* Drawer overlay */}
                    {drawerOpen && (
                        <div 
                            className={`drawer-overlay ${drawerOpen ? 'visible' : ''}`} 
                            onClick={() => setDrawerOpen(false)}
                        />
                    )}

                    <div className="header">
                        <h1>üï∏Ô∏è Mesh</h1>
                        <div style={{fontSize: '0.95em', marginTop: '5px', opacity: '0.95'}}>
                            Connect Without Boundaries - Where Privacy Meets Freedom
                        </div>
                        <div className="status">
                            {connectionState === 'connected' ? '‚úì Connected' : 
                             connectionState === 'connecting' ? 'üîÑ Connecting...' : 
                             '‚ö™ Not Connected'}
                        </div>
                    </div>
                    
                    <div className={`main-content ${connectionState === 'connected' ? 'chat-active' : ''}`}>
                        <div className={`sidebar ${connectionState === 'connected' ? 'drawer' : 'full-width'} ${drawerOpen ? 'open' : ''}`}>
                            <div className="main-connection-section">
                                <h3>üîó Connect to Mesh Network</h3>
                                <p style={{color: '#666', fontSize: '0.9em', marginBottom: '20px', textAlign: 'center'}}>
                                    Connect to other users to join the mesh network
                                </p>

                                {currentView === 'connect' && (
                                    <div style={{textAlign: 'center'}}>
                                        <div style={{marginBottom: '30px'}}>
                                            <button onClick={() => setCurrentView('role-selection')} 
                                                    style={{marginBottom: '15px', fontSize: '1.1em', padding: '15px 25px'}}>
                                                üîó Connect to Someone
                                            </button>
                                        </div>
                                        
                                        <div style={{background: 'rgba(13, 110, 253, 0.1)', border: '1px solid rgba(13, 110, 253, 0.3)', 
                                                    borderRadius: '10px', padding: '20px'}}>
                                            <p style={{color: '#084298', fontSize: '0.9em', margin: '0', lineHeight: '1.4'}}>
                                                <strong>Start Here:</strong> Connect to at least one person to join the mesh network. 
                                                Once connected, you can create rooms and chat with your network.
                                            </p>
                                        </div>
                                    </div>
                                )}

                                {currentView === 'role-selection' && (
                                    <div style={{textAlign: 'center'}}>
                                        <h4 style={{color: '#333', marginBottom: '15px'}}>Choose your role:</h4>
                                        <div className="role-buttons">
                                            <button onClick={createOffer}>üè† Host</button>
                                            <button onClick={() => setCurrentView('join')}>üîó Join</button>
                                        </div>
                                        <button className="back-button" onClick={resetFlow}>‚Üê Back</button>
                                    </div>
                                )}

                                {currentView === 'host' && (
                                    <div style={{textAlign: 'center'}}>
                                        <h4 style={{color: '#333', marginBottom: '10px'}}>üè† Offer Created!</h4>
                                        <p style={{color: '#666', fontSize: '0.9em', marginBottom: '15px'}}>
                                            Share your offer and paste the answer you receive back
                                        </p>
                                        <button onClick={() => {
                                            setModalData({
                                                title: 'Share This Offer',
                                                content: offerData,
                                                customContent: null
                                            });
                                            setShowModal(true);
                                        }} style={{marginBottom: '15px'}}>
                                            üìã Copy Offer
                                        </button>
                                        <textarea 
                                            rows="3" 
                                            placeholder="Paste the answer here..."
                                            value={answerData}
                                            onChange={(e) => setAnswerData(e.target.value)}
                                        />
                                        <button onClick={handleAnswer} style={{width: '100%', marginBottom: '15px'}}>
                                            ‚úÖ Accept Answer
                                        </button>
                                        <button className="back-button" onClick={resetFlow} style={{width: '100%'}}>
                                            ‚Ü©Ô∏è Start Over
                                        </button>
                                    </div>
                                )}

                                {currentView === 'join' && (
                                    <div style={{textAlign: 'center'}}>
                                        <h4 style={{color: '#333', marginBottom: '10px'}}>üîó Step 1: Accept Offer</h4>
                                        <p style={{color: '#666', fontSize: '0.9em', marginBottom: '15px'}}>
                                            Paste the offer you received from the host
                                        </p>
                                        <textarea 
                                            rows="3" 
                                            placeholder="Paste the offer here..."
                                            value={remoteOfferData}
                                            onChange={(e) => setRemoteOfferData(e.target.value)}
                                        />
                                        <button onClick={handleOffer} style={{width: '100%', marginBottom: '15px'}}>
                                            üì© Accept Offer
                                        </button>
                                        <button className="back-button" onClick={resetFlow} style={{width: '100%'}}>
                                            ‚Ü©Ô∏è Start Over
                                        </button>
                                    </div>
                                )}

                                {currentView === 'join-step2' && (
                                    <div style={{textAlign: 'center'}}>
                                        <h4 style={{color: '#333', marginBottom: '10px'}}>üîó Step 2: Share Your Answer</h4>
                                        <p style={{color: '#666', fontSize: '0.9em', marginBottom: '15px'}}>
                                            Send this answer back to the host to complete the connection
                                        </p>
                                        <textarea 
                                            rows="3" 
                                            value={answerData}
                                            readOnly
                                        />
                                        <button onClick={() => {
                                            setModalData({
                                                title: 'Share This Answer',
                                                content: answerData,
                                                customContent: null
                                            });
                                            setShowModal(true);
                                        }} style={{width: '100%', marginBottom: '15px'}}>
                                            üìã Copy Answer
                                        </button>
                                        <button className="back-button" onClick={resetFlow} style={{width: '100%'}}>
                                            ‚Ü©Ô∏è Start Over
                                        </button>
                                    </div>
                                )}

                                {connectionState === 'connected' && (
                                    <div style={{textAlign: 'center'}}>
                                        <div style={{background: 'rgba(25, 135, 84, 0.1)', border: '1px solid rgba(25, 135, 84, 0.3)', 
                                                    borderRadius: '10px', padding: '20px', marginBottom: '25px'}}>
                                            <p style={{color: '#0f5132', fontSize: '1em', margin: '0', fontWeight: '600'}}>
                                                ‚úì Connected to Mesh Network!
                                            </p>
                                        </div>
                                        
                                        <div style={{display: 'flex', gap: '15px', marginBottom: '25px'}}>
                                            <button onClick={createRoom} style={{flex: 1}}>üè† Create Room</button>
                                            <button onClick={() => setCurrentView('role-selection')} style={{flex: 1, background: 'rgba(255,255,255,0.8)', color: '#333'}}>üîó Connect More</button>
                                        </div>
                                        
                                        <div style={{borderTop: '1px solid rgba(0,0,0,0.1)', paddingTop: '20px'}}>
                                            <h5 style={{color: '#333', marginBottom: '10px'}}>Join a Room</h5>
                                            <p style={{color: '#888', fontSize: '0.85em', marginBottom: '15px'}}>Enter a room code from someone in your mesh:</p>
                                            <div style={{marginBottom: '15px'}}>
                                                <input 
                                                    type="text" 
                                                    placeholder="Enter room code" 
                                                    value={roomCode}
                                                    onChange={(e) => setRoomCode(e.target.value.toUpperCase())}
                                                    style={{width: '100%', textAlign: 'center', padding: '12px', fontSize: '1em'}}
                                                />
                                            </div>
                                        </div>
                                    </div>
                                )}
                            </div>

                            {connectionState !== 'connected' && (
                                <div className="collapsible-sections-container">
                                    <CollapsibleSection 
                                        title="üë• Connected Peers (0)"
                                        expanded={sectionsExpanded.peers}
                                        onToggle={() => toggleSection('peers')}
                                    >
                                        <div className="peer-list">
                                            <p style={{color: '#888', fontSize: '0.9em', textAlign: 'center'}}>
                                                No connected peers yet
                                            </p>
                                        </div>
                                    </CollapsibleSection>

                                    <CollapsibleSection 
                                        title="üîë Your Identity"
                                        expanded={sectionsExpanded.identity}
                                        onToggle={() => toggleSection('identity')}
                                    >
                                        <div className="identity-section">
                                            <div>
                                                <label>Username:</label>
                                                <input 
                                                    type="text" 
                                                    value={username}
                                                    onChange={(e) => setUsername(e.target.value)}
                                                    placeholder="Enter your name"
                                                />
                                            </div>
                                            <div className="key-display">
                                                Public Key: {publicKey || 'Generating keys...'}
                                            </div>
                                            <div style={{display: 'flex', gap: '5px', marginTop: '12px'}}>
                                                <button onClick={generateNewKeys} style={{flex: 1}}>üîÑ New Keys</button>
                                                <button onClick={exportPrivateKey} style={{flex: 1}}>üì§ Export</button>
                                                <button style={{flex: 1}}>üì• Import</button>
                                            </div>
                                        </div>
                                    </CollapsibleSection>

                                    <CollapsibleSection 
                                        title="üìä Statistics"
                                        expanded={sectionsExpanded.stats}
                                        onToggle={() => toggleSection('stats')}
                                    >
                                        <div className="stats">
                                            Messages sent: {messagesSent}<br/>
                                            Messages received: {messagesReceived}<br/>
                                            Messages relayed: {messagesRelayed}
                                        </div>
                                    </CollapsibleSection>

                                    <CollapsibleSection 
                                        title="üîí Why Mesh is Most Private & Secure"
                                        expanded={sectionsExpanded.privacy}
                                        onToggle={() => toggleSection('privacy')}
                                    >
                                        <div className="privacy-grid">
                                            <div className="privacy-card">
                                                <h4>üö´ Zero Servers</h4>
                                                <p>Your messages never touch our servers or anyone else's. Direct peer-to-peer connections mean only you and your contacts see your data.</p>
                                            </div>
                                            
                                            <div className="privacy-card">
                                                <h4>üîê End-to-End Encryption</h4>
                                                <p>Every message is cryptographically signed with ECDSA-P256. Even if intercepted, your communications remain mathematically unbreakable.</p>
                                            </div>
                                            
                                            <div className="privacy-card">
                                                <h4>üåê Mesh Network</h4>
                                                <p>Messages relay through connected peers, creating a resilient network that can't be shut down by any central authority.</p>
                                            </div>
                                            
                                            <div className="privacy-card">
                                                <h4>üë§ True Anonymity</h4>
                                                <p>No phone numbers, email addresses, or personal information required. Generate new identities instantly with zero trace.</p>
                                            </div>
                                            
                                            <div className="privacy-card">
                                                <h4>üè† Runs Locally</h4>
                                                <p>Everything happens in your browser using WebRTC. No apps to install, no permissions to grant, no data to mine.</p>
                                            </div>
                                            
                                            <div className="privacy-card">
                                                <h4>üîÑ Self-Healing</h4>
                                                <p>If one peer goes offline, messages automatically route through others. The network adapts and survives without central coordination.</p>
                                            </div>
                                        </div>
                                        
                                        <div className="privacy-comparison">
                                            <h4 style={{color: '#333', margin: '0 0 15px 0', textAlign: 'center', fontSize: '1.1em'}}>
                                                ü•ä Mesh vs Traditional Chat Apps
                                            </h4>
                                            <div className="comparison-table">
                                                <div className="comparison-header">Feature</div>
                                                <div className="comparison-header">üï∏Ô∏è Mesh</div>
                                                <div className="comparison-header">üì± Traditional Apps</div>
                                                
                                                <div className="comparison-item">Server Storage</div>
                                                <div className="comparison-item comparison-mesh">Never ‚úì</div>
                                                <div className="comparison-item comparison-traditional">Always ‚úó</div>
                                                
                                                <div className="comparison-item">Metadata Collection</div>
                                                <div className="comparison-item comparison-mesh">Impossible ‚úì</div>
                                                <div className="comparison-item comparison-traditional">Extensive ‚úó</div>
                                                
                                                <div className="comparison-item">Government Backdoors</div>
                                                <div className="comparison-item comparison-mesh">Cannot Exist ‚úì</div>
                                                <div className="comparison-item comparison-traditional">Often Present ‚úó</div>
                                                
                                                <div className="comparison-item">Single Point of Failure</div>
                                                <div className="comparison-item comparison-mesh">None ‚úì</div>
                                                <div className="comparison-item comparison-traditional">Central Servers ‚úó</div>
                                                
                                                <div className="comparison-item">Identity Requirements</div>
                                                <div className="comparison-item comparison-mesh">Zero ‚úì</div>
                                                <div className="comparison-item comparison-traditional">Phone/Email ‚úó</div>
                                                
                                                <div className="comparison-item">Censorship Resistance</div>
                                                <div className="comparison-item comparison-mesh">Maximum ‚úì</div>
                                                <div className="comparison-item comparison-traditional">Minimal ‚úó</div>
                                            </div>
                                        </div>
                                        
                                        <div style={{background: 'rgba(255, 255, 255, 0.7)', padding: '20px', borderRadius: '12px', borderLeft: '4px solid #4caf50'}}>
                                            <h4 style={{color: '#333', margin: '0 0 10px 0', display: 'flex', alignItems: 'center', gap: '8px'}}>
                                                üéØ The Bottom Line
                                            </h4>
                                            <p style={{color: '#666', margin: '0', fontSize: '0.95em', lineHeight: '1.6'}}>
                                                <strong>Mesh doesn't just protect your privacy - it makes surveillance architecturally impossible.</strong> 
                                                Unlike Signal, WhatsApp, or Telegram that still route through servers (creating chokepoints for control), 
                                                Mesh creates a truly distributed network where your conversations exist only between you and your contacts. 
                                                No company can sell your data, no government can demand backdoors, and no hacker can breach a server that doesn't exist.
                                            </p>
                                        </div>
                                    </CollapsibleSection>
                                </div>
                            )}

                            {/* Chat tabs for connected state */}
                            {connectionState === 'connected' && (
                                <div style={{marginTop: '20px', borderTop: '1px solid rgba(0,0,0,0.1)', paddingTop: '20px'}}>
                                    <div className="section-header">
                                        <span>üí¨ Active Chats</span>
                                    </div>
                                    <div className="chat-tabs-sidebar">
                                        {Array.from(activeChats.entries()).map(([chatId, chat]) => (
                                            <button 
                                                key={chatId}
                                                className={`chat-tab ${currentChatId === chatId ? 'active' : ''}`}
                                                onClick={() => switchChat(chatId)}
                                            >
                                                <span>{chat.type === 'group' ? 'üë•' : 'üí¨'} {chat.name}</span>
                                                {chat.unreadCount > 0 && (
                                                    <span className="unread-indicator">{chat.unreadCount}</span>
                                                )}
                                            </button>
                                        ))}
                                    </div>
                                </div>
                            )}

                            {/* QR Scanner section */}
                            {qrScanning && (
                                <div style={{marginTop: '20px'}}>
                                    <div className="camera-container">
                                        <video ref={qrVideoRef} autoPlay style={{width: '100%', maxWidth: '300px'}} />
                                    </div>
                                    <button onClick={stopQRScanner} style={{marginTop: '10px'}}>
                                        Stop Scanner
                                    </button>
                                </div>
                            )}
                        </div>

                        <div className={`chat-area ${connectionState === 'connected' ? 'connected' : ''}`}>
                            <div className="messages">
                                {messages.map(message => (
                                    <div key={message.id} className={`message ${message.isOwn ? 'own' : 'peer'}`}>
                                        <div className="message-header">{message.sender}</div>
                                        <div className="message-content">{message.content}</div>
                                    </div>
                                ))}
                            </div>

                            {isInCall && (
                                <div style={{padding: '20px', background: 'rgba(0,0,0,0.1)', borderRadius: '10px', margin: '20px'}}>
                                    <div className="call-controls">
                                        <button onClick={endCall} style={{background: '#dc3545'}}>üìû End Call</button>
                                    </div>
                                    <div className="video-streams">
                                        <div className="video-container">
                                            <video ref={localVideoRef} autoPlay muted />
                                            <div style={{position: 'absolute', bottom: '10px', left: '10px', color: 'white', 
                                                        background: 'rgba(0,0,0,0.5)', padding: '5px', borderRadius: '3px', fontSize: '0.8em'}}>
                                                You
                                            </div>
                                        </div>
                                        <div className="video-container">
                                            <video ref={remoteVideoRef} autoPlay />
                                            <div style={{position: 'absolute', bottom: '10px', left: '10px', color: 'white', 
                                                        background: 'rgba(0,0,0,0.5)', padding: '5px', borderRadius: '3px', fontSize: '0.8em'}}>
                                                Remote
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            )}

                            <div className="input-area">
                                <div className="input-group">
                                    <input 
                                        ref={messageInputRef}
                                        type="text" 
                                        placeholder="Type your message..."
                                        onKeyPress={(e) => e.key === 'Enter' && sendMessage()}
                                    />
                                    <button onClick={sendMessage}>üì§ Send</button>
                                    <button onClick={startCall} style={{background: '#007bff'}}>üìû</button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <Modal 
                        show={showModal}
                        title={modalData.title}
                        content={modalData.content}
                        customContent={modalData.customContent}
                        onClose={closeModal}
                        onCopy={copyModalContent}
                    />
                </div>
            );
        };

        // Render the app
        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>